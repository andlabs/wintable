// 16 august 2014
#include "tablepriv.h"

// TODO wait did we really need WM_MOUSELEAVE after all?

// TODO http://stackoverflow.com/a/22695333/3408572

// returns S_FALSE if we're outside the client rect or not in a checkbox
static HRESULT lParamToCheckbox(struct table *t, struct metrics *m, LPARAM lParam, struct rowcol *rc, RECT *rCell, RECT *rCheckbox)
{
	HRESULT hr;

	// TODO does this make sure we're not in the client rect?
	hr = lParamToRowColumn(t, m, lParam, rc);
	if (hr != S_OK)
		return hr;
	if (rc->row == -1 || rc->column == -1)
		return S_FALSE;
	if (t->columnTypes[rc->column] != tableColumnCheckbox)
		return S_FALSE;
	hr = rowColumnToClientRect(t, m, *rc, rCell);
	if (hr != S_OK)			// handles the S_FALSE case
		return hr;
	*rCheckbox = *rCell;
	toCellContentRect(t, rCheckbox, 0, m->checkboxWidth, m->checkboxHeight);
	return S_OK;
}

// TODO what happens if any of these functions fail?
EVENTHANDLER(checkboxMouseMoveHandler)
{
	// TODO see http://stackoverflow.com/a/28731761/3408572
	// TODO when rewriting, handle captures/the possibility that the mouse may not be in the client rect

	struct rowcol rc;
	RECT rCell, rCheckbox;
	HRESULT hr;

	// we don't need to do any sort of logic to figure out what specifically to draw here
	// the drawing code will figure that out
	// we simply need to mark the old and new cells for redraw
	if (t->checkboxMouseMoved) {		// mark the previous cell in case we've changed cells
		hr = lParamToCheckbox(t, m, t->checkboxMouseMoveLPARAM, &rc, &rCell, &rCheck);
		if (hr != S_OK && hr != S_FALSE)
			;	// TODO
		if (hr != S_FALSE)
			if (InvalidateRect(t->hwnd, &rCell, TRUE) == 0)
				;	// TODO
	}
	t->checkboxMouseMoved = TRUE;
	t->checkboxMouseMoveLPARAM = lParam;
	// TODO see if we need to get rid of code duplication here
	hr = lParamToCheckbox(t, m, t->checkboxMouseMoveLPARAM, &rc, &rCell, &rCheck);
	if (hr != S_OK && hr != S_FALSE)
		;	// TODO
	if (hr != S_FALSE)
		if (InvalidateRect(t->hwnd, &rCell, TRUE) == 0)
			;	// TODO
	return TRUE;
}

// TODO if we click on a partially invisible checkbox, should the mouse be moved up along with the scroll?
// TODO what happens if any of these fail?
EVENTHANDLER(checkboxMouseDownHandler)
{
$	determine if the mouse landed on a checkbox
$	if so
$		SetCapture()
$		mark that we are clicking a checkbox
	return TRUE;
}

// TODO what happens if any of these fail?
EVENTHANDLER(checkboxMouseUpHandler)
{
$	if we weren't clicking a checkbox
		return FALSE;
$	leave checkbox clicking mode
$	ReleaseCapture()
$	if the mouse was released in the same checkbox
$		toggle it
$	TODO else return FALSE?
$	TODO redraw the checkbox in question
}

// TODO what happens if any of these fail?
EVENTHANDLER(checkboxCaptureChangedHandler)
{
$	if we weren't in checkbox clicking mode
		return FALSE;
$	leave checkbox clicking mode
$	TODO redraw the checkbox in question
	return TRUE;
}
